# 流式类型定义案例

## 1. StreamChunk 接口定义

```typescript
// 流式响应的数据块类型
interface StreamChunk {
  done: boolean;           // 是否完成
  message?: {
    role: string;          // 消息角色
    content: string;       // 消息内容片段
  };
}
```

## 2. 在 services/chat.ts 中定义

```typescript
// src/services/chat.ts

// 流式响应的数据块类型
interface StreamChunk {
  done: boolean;
  message?: {
    role: string;
    content: string;
  };
}

// 如果需要导出
export type { StreamChunk };
```

## 3. StreamChunk 数据示例

```typescript
// 示例 1：数据块
{
  "done": false,
  "message": {
    "role": "assistant",
    "content": "你好"
  }
}

// 示例 2：另一个数据块
{
  "done": false,
  "message": {
    "role": "assistant",
    "content": "！我是"
  }
}

// 示例 3：完成标记
{
  "done": true
}
```

## 4. 为什么需要 StreamChunk？

### 传统方式 vs 流式方式

```typescript
// 传统方式：等待完整响应
interface ApiResponse {
  message: {
    role: string;
    content: string;  // 完整内容
  };
}

// 流式方式：逐块接收
interface StreamChunk {
  done: boolean;
  message?: {
    role: string;
    content: string;  // 内容片段
  };
}
```

### 数据流示意

```
API 响应流（多个 StreamChunk）:
Chunk 1: { done: false, message: { role: "assistant", content: "你好" } }
Chunk 2: { done: false, message: { role: "assistant", content: "！我是" } }
Chunk 3: { done: false, message: { role: "assistant", content: "前端" } }
Chunk 4: { done: false, message: { role: "assistant", content: "导师" } }
Chunk 5: { done: true }

前端逐块拼接:
"你好" → "你好！我是" → "你好！我是前端" → "你好！我是前端导师"
```

## 5. 类型工具

```typescript
// 提取 StreamChunk 的 message 类型
type StreamMessage = NonNullable<StreamChunk['message']>;

// 提取 content 类型
type StreamContent = StreamMessage['content'];

// 检查是否完成
type IsDone = StreamChunk['done'];
```

## 6. 实际使用示例

```typescript
// 在 sendMessageStream 中使用
async function sendMessageStream(
  context: Message[],
  onChunk: (content: string) => void,
  onComplete: () => void
) {
  const response = await fetch('...', {
    method: 'POST',
    body: JSON.stringify({ stream: true }),
  });

  const reader = response.body.getReader();

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    const chunk = decoder.decode(value);
    const lines = chunk.split('\n');

    for (const line of lines) {
      const data: StreamChunk = JSON.parse(line);

      if (data.message?.content) {
        onChunk(data.message.content);  // 实时回调
      }

      if (data.done) {
        onComplete();  // 流式输出完成
        return;
      }
    }
  }
}
```

## 7. 错误处理类型

```typescript
// 定义可能的错误类型
type StreamError =
  | { type: 'network'; message: string }
  | { type: 'parse'; message: string }
  | { type: 'timeout'; message: string };

// 扩展 StreamChunk（可选）
interface StreamChunkWithError extends StreamChunk {
  error?: {
    type: string;
    message: string;
  };
}
```

## 8. 测试用例

```typescript
// 测试 StreamChunk 解析
const testChunk1: StreamChunk = {
  done: false,
  message: {
    role: 'assistant',
    content: 'Hello',
  },
};

const testChunk2: StreamChunk = {
  done: true,
};

console.log(testChunk1.done); // false
console.log(testChunk1.message?.content); // "Hello"
console.log(testChunk2.done); // true
```

## 你的任务

1. 在 `src/services/chat.ts` 中添加 `StreamChunk` 接口
2. 导出 `StreamChunk` 类型供其他模块使用
3. 理解流式数据结构

完成后告诉我："我写好了，你检查一下 @src/services/chat.ts"