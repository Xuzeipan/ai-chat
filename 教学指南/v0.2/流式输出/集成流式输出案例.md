# 集成流式输出案例

## 1. 完整的 App 组件实现

```typescript
import React, { useState } from 'react';
import { ModeSelector } from './components/ModeSelector';
import { ChatList } from './components/ChatList';
import { ChatInput } from './components/ChatInput';
import { Message, Mode } from './types';
import { sendMessageStream } from './services/chat';
import getContext from './utils/context';
import MODES from './config/modes';
import styles from './App.module.css';

interface AppState {
  messages: Message[];
  loading: boolean;
  error: string | null;
  currentMode: Mode;
  modes: Mode[];
}

function App() {
  const [state, setState] = useState<AppState>({
    messages: [],
    loading: false,
    error: null,
    currentMode: MODES[0],
    modes: MODES,
  });

  // 模式切换处理
  const handleModeChange = (mode: Mode) => {
    setState((prev) => ({
      ...prev,
      currentMode: mode,
    }));
  };

  // 发送消息处理
  const handleSend = async (content: string) => {
    if (!content.trim() || state.loading) return;

    // 1. 添加用户消息
    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content: content.trim(),
    };

    const newMessages = [...state.messages, userMessage];
    setState((prev) => ({
      ...prev,
      messages: newMessages,
      loading: true,
      error: null,
    }));

    // 2. 创建空的 AI 消息占位符
    const assistantMessageId = (Date.now() + 1).toString();
    const assistantMessage: Message = {
      id: assistantMessageId,
      role: 'assistant',
      content: '',
    };

    setState((prev) => ({
      ...prev,
      messages: [...newMessages, assistantMessage],
    }));

    // 3. 获取上下文（包含 system prompt）
    const context = getContext(newMessages, state.currentMode);

    // 4. 流式发送给模型
    try {
      await sendMessageStream(
        context,
        // onChunk: 接收到新内容时更新消息
        (newContent: string) => {
          setState((prev) => ({
            ...prev,
            messages: prev.messages.map((msg) =>
              msg.id === assistantMessageId
                ? { ...msg, content: msg.content + newContent }
                : msg
            ),
          }));
        },
        // onComplete: 流式输出完成
        () => {
          setState((prev) => ({
            ...prev,
            loading: false,
          }));
        },
        // onError: 错误处理
        (error: Error) => {
          setState((prev) => ({
            ...prev,
            loading: false,
            error: error.message,
          }));
        }
      );
    } catch (error) {
      setState((prev) => ({
        ...prev,
        loading: false,
        error: (error as Error).message,
      }));
    }
  };

  // 清除错误
  const handleClearError = () => {
    setState((prev) => ({
      ...prev,
      error: null,
    }));
  };

  return (
    <div className={styles.app}>
      {/* 模式选择器 */}
      <ModeSelector
        modes={state.modes}
        currentMode={state.currentMode}
        onModeChange={handleModeChange}
      />

      {/* 错误提示 */}
      {state.error && (
        <div className={styles.errorBanner}>
          <span className={styles.errorMessage}>{state.error}</span>
          <button
            className={styles.errorClose}
            onClick={handleClearError}
          >
            ✕
          </button>
        </div>
      )}

      {/* 聊天列表 */}
      <ChatList
        messages={state.messages}
        loading={state.loading}
      />

      {/* 输入框 */}
      <ChatInput
        onSend={handleSend}
        isLoading={state.loading}
      />
    </div>
  );
}

export default App;
```

## 2. 流式输出状态管理要点

### 2.1 创建消息占位符

```typescript
// 在流式输出开始时，创建一个空的消息占位符
const assistantMessageId = (Date.now() + 1).toString();
const assistantMessage: Message = {
  id: assistantMessageId,
  role: 'assistant',
  content: '',  // 初始为空
};

// 添加到消息列表
setState(prev => ({
  ...prev,
  messages: [...newMessages, assistantMessage],
}));
```

### 2.2 逐字更新消息内容

```typescript
// 在 onChunk 回调中，逐字更新消息内容
onChunk: (newContent: string) => {
  setState(prev => ({
    ...prev,
    messages: prev.messages.map(msg =>
      msg.id === assistantMessageId
        ? { ...msg, content: msg.content + newContent }  // 追加新内容
        : msg
    ),
  }));
}
```

### 2.3 完成时更新 loading 状态

```typescript
// 在 onComplete 回调中，关闭 loading 状态
onComplete: () => {
  setState(prev => ({
    ...prev,
    loading: false,
  }));
}
```

## 3. 测试流式输出

### 测试场景 1：长文本输出

```
用户: 写一个快速排序算法

AI 回复（流式显示）:
快速 → 快速排 → 快速排序 → 快速排序（ → 快速排序（Quick → 快速排序（QuickSort → ...）
```

### 测试场景 2：代码块输出

```
用户: 写一个 React 组件

AI 回复（流式显示）:
``` → ```java → ```javasc → ```javascri → ```javascrip → ```javascript → ...

function MyComponent() {
  return <div>Hello</div>;
}
```
```

### 测试场景 3：网络中断

```
1. 开始发送消息
2. 中途断开网络
3. 验证错误提示正确显示
4. 验证可以继续发送新消息
```

## 4. 验证点

- ✅ 流式输出实时显示，有打字机效果
- ✅ 消息内容逐字追加，不重复
- ✅ 流式输出完成后，消息完整显示
- ✅ Loading 状态在流式输出期间保持 true
- ✅ 流式输出完成后，loading 状态变为 false
- ✅ 错误时显示错误提示，不影响后续使用
- ✅ 网络中断时，能正确处理错误

## 5. 性能优化

```typescript
// 使用 useMemo 优化上下文计算
import { useMemo } from 'react';

function App() {
  const [state, setState] = useState<AppState>(initialState);

  // 缓存上下文计算
  const context = useMemo(() => {
    return getContext([...state.messages, userMessage], state.currentMode);
  }, [state.messages, state.currentMode]);

  // 使用缓存的 context
  await sendMessageStream(context, onChunk, onComplete, onError);
}
```

```typescript
// 限制更新频率（使用防抖）
function throttle<T extends (...args: any[]) => void>(
  func: T,
  delay: number
): T {
  let lastCall = 0;
  return ((...args: any[]) => {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      func(...args);
    }
  }) as T;
}

// 在 onChunk 中使用
const throttledOnChunk = throttle((content: string) => {
  setState(prev => ({
    ...prev,
    messages: prev.messages.map(msg =>
      msg.id === assistantMessageId
        ? { ...msg, content: msg.content + content }
        : msg
    ),
  }));
}, 50);  // 最多每 50ms 更新一次
```

## 6. 调试技巧

```typescript
// 添加调试日志
const handleSend = async (content: string) => {
  console.log('开始发送消息:', content);
  console.time('stream');

  await sendMessageStream(
    context,
    (newContent) => {
      console.log('收到内容片段:', newContent);
      // 更新状态...
    },
    () => {
      console.timeEnd('stream');
      console.log('流式输出完成');
      // 完成处理...
    },
    (error) => {
      console.error('流式输出错误:', error);
      // 错误处理...
    }
  );
};
```

## 你的任务

1. 更新 `src/App.tsx`，集成流式输出
2. 实现流式输出的状态更新逻辑
3. 测试流式输出的实时性和稳定性
4. 验证错误处理

完成后告诉我："我写好了，你检查一下 @src/App.tsx"