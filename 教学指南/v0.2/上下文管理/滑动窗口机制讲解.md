# 滑动窗口机制讲解

## 什么是滑动窗口？

**滑动窗口**是一种管理有限资源的策略，在 AI 对话中用于控制发送给模型的对话历史数量。

## 为什么要用滑动窗口？

### 问题：Token 限制

AI 模型有最大 token 限制，通常是 4096 或 8192 个 token。如果发送太多历史消息，会：

1. **超出限制**：模型拒绝处理
2. **成本增加**：更多 token = 更高费用
3. **响应变慢**：处理更多数据需要更长时间

### 解决方案：只保留最近的对话

```
完整历史: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T]
           ↑
       contextLength = 5

发送给模型: [System, P, Q, R, S, T]
```

## 工作原理

### 1. 固定窗口大小

```typescript
const contextLength = 5;  // 窗口大小固定为 5
```

### 2. 滑动机制

随着新消息的到来，窗口"滑动"到最新的消息：

```
初始状态:
历史: [A, B, C, D, E]
窗口: [A, B, C, D, E]  ← 5 条

新消息 F 到来:
历史: [A, B, C, D, E, F]
窗口: [B, C, D, E, F]  ← 滑动到最新 5 条，A 被移出

新消息 G 到来:
历史: [A, B, C, D, E, F, G]
窗口: [C, D, E, F, G]  ← 继续滑动，B 被移出
```

### 3. 代码实现

```typescript
function getContext(messages: Message[], mode: Mode): Message[] {
  // 1. 创建 system prompt
  const systemMessage: Message = {
    id: 'system',
    role: 'system',
    content: mode.systemPrompt,
  };

  // 2. 使用 slice(-n) 获取最近 n 条消息
  const recentMessages = messages.slice(-mode.contextLength);

  // 3. 组合返回
  return [systemMessage, ...recentMessages];
}
```

## 不同模式的窗口大小

```typescript
// 普通聊天模式：简单问题，不需要太多上下文
{
  id: 'normal',
  contextLength: 10,  // 保留最近 10 条
}

// 前端导师模式：技术讨论，需要更多上下文理解问题
{
  id: 'frontend-mentor',
  contextLength: 15,  // 保留最近 15 条
}

// 代码审查模式：需要完整的代码上下文
{
  id: 'code-reviewer',
  contextLength: 20,  // 保留最近 20 条
}
```

## 实际例子

### 场景：代码审查对话

```
用户: 帮我看看这段代码
AI: 好的，请贴出代码
用户: function sum(a, b) { return a + b; }
AI: 代码看起来不错，但建议添加类型检查
用户: 怎么加？
AI: 可以这样写...
用户: 明白了
用户: 再帮我看看另一段
AI: 好的，请贴出
```

**如果 contextLength = 3**：
```
发送给模型的上下文:
[
  { role: "system", content: "你是代码审查专家..." },
  { role: "user", content: "明白了" },
  { role: "user", content: "再帮我看看另一段" },
  { role: "assistant", content: "好的，请贴出" }
]

注意：前面的代码讨论被移除了！
```

**如果 contextLength = 10**：
```
发送给模型的上下文:
[
  { role: "system", content: "你是代码审查专家..." },
  { role: "user", content: "帮我看看这段代码" },
  { role: "assistant", content: "好的，请贴出代码" },
  { role: "user", content: "function sum(a, b) { return a + b; }" },
  { role: "assistant", content: "代码看起来不错..." },
  { role: "user", content: "怎么加？" },
  { role: "assistant", content: "可以这样写..." },
  { role: "user", content: "明白了" },
  { role: "user", content: "再帮我看看另一段" },
  { role: "assistant", content: "好的，请贴出" }
]

注意：保留了完整的代码讨论历史！
```

## 优化策略

### 策略 1：标记重要消息

```typescript
interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  important?: boolean;  // 标记重要消息
}

function getContextOptimized(messages: Message[], mode: Mode): Message[] {
  const systemMessage = { id: 'system', role: 'system', content: mode.systemPrompt };

  // 优先保留重要消息
  const importantMessages = messages.filter(m => m.important);
  const normalMessages = messages.filter(m => !m.important);

  // 取最近 N 条普通消息
  const recentNormal = normalMessages.slice(-(mode.contextLength - importantMessages.length));

  return [systemMessage, ...importantMessages, ...recentNormal];
}
```

### 策略 2：动态调整窗口大小

```typescript
function getDynamicContextLength(mode: Mode, messages: Message[]): number {
  // 如果是代码审查模式，且消息包含代码，增加上下文长度
  if (mode.id === 'code-reviewer') {
    const hasCode = messages.some(m => m.content.includes('```'));
    return hasCode ? 30 : mode.contextLength;
  }
  return mode.contextLength;
}
```

### 策略 3：对话摘要

```typescript
// 对旧对话进行摘要，节省 token
function summarizeOldMessages(messages: Message[]): Message[] {
  if (messages.length <= 10) return messages;

  const oldMessages = messages.slice(0, -10);
  const summary = generateSummary(oldMessages);  // 调用 API 生成摘要

  return [
    {
      id: 'summary',
      role: 'assistant',
      content: `[摘要] ${summary}`,
    },
    ...messages.slice(-10),
  ];
}
```

## 总结

**滑动窗口的核心思想**：
1. **限制数量**：只保留最近 N 条消息
2. **动态更新**：新消息到来时，旧消息被移出
3. **保持连贯**：确保对话上下文连贯

**优点**：
- ✅ 节省 token，降低成本
- ✅ 提高响应速度
- ✅ 避免超出模型限制
- ✅ 保持对话连贯性

**缺点**：
- ❌ 丢失早期对话信息
- ❌ 可能影响长期记忆
- ❌ 需要合理设置窗口大小

这就是滑动窗口机制的核心原理！