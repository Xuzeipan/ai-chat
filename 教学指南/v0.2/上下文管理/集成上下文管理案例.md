# 集成上下文管理案例

## 1. 更新 sendMessage 函数

```typescript
import { Message } from '../types';

/**
 * 发送消息到 Ollama API
 * @param content - 用户消息内容
 * @param context - 上下文消息数组（包含 system prompt）
 * @returns AI 回复内容
 */
export async function sendMessage(
  content: string,
  context: Message[]
): Promise<string> {
  const request = {
    model: "qwen2.5-coder:7b",
    messages: context.map(msg => ({
      role: msg.role,
      content: msg.content,
    })),
    stream: false,
  };

  try {
    const response = await fetch('http://localhost:11434/api/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data.message.content;
  } catch (error) {
    throw error;
  }
}
```

## 2. 在 App 中集成上下文管理

```typescript
import React, { useState } from 'react';
import { ModeSelector } from './components/ModeSelector';
import { ChatList } from './components/ChatList';
import { ChatInput } from './components/ChatInput';
import { Message, Mode } from './types';
import { sendMessage } from './services/chat';
import getContext from './utils/context';
import MODES from './config/modes';
import styles from './App.module.css';

function App() {
  const [state, setState] = useState<AppState>({
    messages: [],
    loading: false,
    error: null,
    currentMode: MODES[0],
    modes: MODES,
  });

  const handleModeChange = (mode: Mode) => {
    setState((prev) => ({
      ...prev,
      currentMode: mode,
    }));
  };

  const handleSend = async (content: string) => {
    if (!content.trim() || state.loading) return;

    // 1. 添加用户消息
    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content: content.trim(),
    };

    const newMessages = [...state.messages, userMessage];
    setState((prev) => ({
      ...prev,
      messages: newMessages,
      loading: true,
      error: null,
    }));

    // 2. 获取上下文（包含 system prompt）
    const context = getContext(newMessages, state.currentMode);

    // 3. 发送给 API
    try {
      const reply = await sendMessage(content, context);

      // 4. 添加 AI 回复
      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: reply,
      };

      setState((prev) => ({
        ...prev,
        messages: [...newMessages, assistantMessage],
        loading: false,
      }));
    } catch (error) {
      setState((prev) => ({
        ...prev,
        loading: false,
        error: (error as Error).message,
      }));
    }
  };

  return (
    <div className={styles.app}>
      <ModeSelector
        modes={state.modes}
        currentMode={state.currentMode}
        onModeChange={handleModeChange}
      />
      <ChatList messages={state.messages} loading={state.loading} />
      <ChatInput onSend={handleSend} isLoading={state.loading} />
    </div>
  );
}

export default App;
```

## 3. 测试上下文管理

### 测试场景 1：普通聊天模式
```
用户: 你好
AI: 你好！有什么我可以帮助你的吗？
用户: 今天天气怎么样？
AI: 我是一个 AI 助手，无法获取实时天气信息。建议你查看天气预报应用或网站。
```

### 测试场景 2：前端导师模式
```
用户: 怎么学 React？
AI: 学习 React 我建议按以下步骤进行：

1. **基础准备**
   - 熟悉 JavaScript 和 ES6+ 语法
   - 了解 HTML 和 CSS 基础

2. **React 核心**
   - JSX 语法
   - 组件和 Props
   - State 和 Lifecycle

3. **进阶内容**
   - Hooks（useState, useEffect, useContext）
   - React Router（路由）
   - 状态管理（Redux, Zustand）

你想从哪个部分开始学习？
```

### 测试场景 3：代码审查模式
```
用户: 帮我看看这段代码
javascript
function sum(a, b) {
  return a + b;
}
AI: 这段代码有以下几个问题：

1. **参数类型检查缺失**：没有验证 a 和 b 是否为数字
2. **错误处理不足**：没有处理可能的异常情况

改进建议：
javascript
function sum(a: number, b: number): number {
  if (typeof a !== 'number' || typeof b !== 'number') {
    throw new TypeError('参数必须是数字');
  }
  return a + b;
}


或者使用 TypeScript 的类型系统自动处理。
```

## 4. 验证点

- ✅ 不同模式下，AI 回复风格明显不同
- ✅ System Prompt 正确注入到上下文中
- ✅ 上下文长度正确控制（普通聊天 10 条，前端导师 15 条，代码审查 20 条）
- ✅ 切换模式后，新的消息使用新的 system prompt
- ✅ 旧的历史消息不受影响

## 5. 调试技巧

```typescript
// 在 sendMessage 中打印上下文
export async function sendMessage(content: string, context: Message[]): Promise<string> {
  console.log('发送给 API 的上下文:', context);
  console.log('上下文长度:', context.length);

  const request = {
    model: "qwen2.5-coder:7b",
    messages: context.map(msg => ({
      role: msg.role,
      content: msg.content,
    })),
    stream: false,
  };

  // ...
}
```

## 6. 性能优化

```typescript
// 使用 useMemo 缓存上下文计算
import { useMemo } from 'react';

function App() {
  const [state, setState] = useState<AppState>(initialState);

  // 缓存上下文计算
  const context = useMemo(() => {
    return getContext(state.messages, state.currentMode);
  }, [state.messages, state.currentMode]);

  // 使用缓存的 context
  const handleSend = async (content: string) => {
    // ...
    const reply = await sendMessage(content, context);
    // ...
  };
}
```

## 7. 修改 src/services/chat.ts

### 当前问题

现有的 `sendMessage` 函数有以下问题：

```typescript
// 当前实现
export async function sendMessage(content: string): Promise<string> {
  const request: OllamaChatRequest = {
    messages: [
      {
        role: "user",
        content,  // ← 只发送单条消息
      },
    ],
    model: "qwen2.5-coder:7b",
    stream: false,
  };
  // ...
}
```

**问题**：
1. ❌ 只接受 content 参数，没有接受上下文
2. ❌ 只发送单条消息，没有包含历史对话
3. ❌ 没有使用 system prompt，无法控制 AI 角色
4. ❌ 没有流式输出，等待完整响应才显示

### 需要的改动

#### 改动 1：修改 sendMessage 函数签名

```typescript
// 修改前
export async function sendMessage(content: string): Promise<string>

// 修改后
export async function sendMessage(
  content: string,
  context: Message[]
): Promise<string>
```

#### 改动 2：使用 context 参数

```typescript
export async function sendMessage(
  content: string,
  context: Message[]
): Promise<string> {
  const request = {
    model: "qwen2.5-coder:7b",
    messages: context.map(msg => ({  // ← 使用 context 而不是只发送单条消息
      role: msg.role,
      content: msg.content,
    })),
    stream: false,
  };

  // ... 其余代码不变
}
```

#### 改动 3：完整的修改后代码

```typescript
import type { OllamaChatRequest, OllamaChatResponse, Message } from "../types";

// API 配置
const API_BASE_URL = "http://localhost:11434/api";

/**
 * 发送消息到 Ollama API
 * @param content - 用户消息内容（已废弃，保留用于向后兼容）
 * @param context - 上下文消息数组（包含 system prompt 和历史消息）
 * @returns AI 回复内容
 */
export async function sendMessage(
  content: string,
  context: Message[]
): Promise<string> {
  const request: OllamaChatRequest = {
    model: "qwen2.5-coder:7b",
    messages: context.map(msg => ({
      role: msg.role,
      content: msg.content,
    })),
    stream: false,
  };

  try {
    const response = await fetch(`${API_BASE_URL}/chat`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data: OllamaChatResponse = await response.json();
    return data.message.content;
  } catch (error) {
    console.error("API 请求失败：", error);
    throw error;
  }
}
```

### 注意事项

⚠️ **content 参数已废弃**：虽然保留了 `content` 参数以保持向后兼容，但实际使用的是 `context` 参数。在未来的流式输出版本中，这个参数可能会被完全移除。

## 你的任务

1. 更新 `src/services/chat.ts`，让 sendMessage 接受 context 参数
2. 更新 `src/App.tsx`，在 handleSend 中使用 getContext
3. 测试不同模式的回答风格
4. 验证上下文长度控制

完成后告诉我："我写好了，你检查一下 @src/App.tsx"