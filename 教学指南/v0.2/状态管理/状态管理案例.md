# 状态管理案例 - 模式系统 + 流式输出

## 1. 完整的 App 组件实现

```typescript
import React, { useState } from 'react';
import { ModeSelector } from './components/ModeSelector';
import { ChatList } from './components/ChatList';
import { ChatInput } from './components/ChatInput';
import { Message, Mode } from './types';
import { sendMessageStream } from './services/chat';
import getContext from './utils/context';
import MODES from './config/modes';
import styles from './App.module.css';

interface AppState {
  messages: Message[];
  loading: boolean;
  error: string | null;
  currentMode: Mode;
  modes: Mode[];
}

function App() {
  const [state, setState] = useState<AppState>({
    messages: [],
    loading: false,
    error: null,
    currentMode: MODES[0],
    modes: MODES,
  });

  // 模式切换处理
  const handleModeChange = (mode: Mode) => {
    setState((prev) => ({
      ...prev,
      currentMode: mode,
    }));
  };

  // 发送消息处理
  const handleSend = async (content: string) => {
    if (!content.trim() || state.loading) return;

    // 1. 添加用户消息
    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content: content.trim(),
    };

    const newMessages = [...state.messages, userMessage];
    setState((prev) => ({
      ...prev,
      messages: newMessages,
      loading: true,
      error: null,
    }));

    // 2. 创建空的 AI 消息占位符
    const assistantMessageId = (Date.now() + 1).toString();
    const assistantMessage: Message = {
      id: assistantMessageId,
      role: 'assistant',
      content: '',
    };

    setState((prev) => ({
      ...prev,
      messages: [...newMessages, assistantMessage],
    }));

    // 3. 获取上下文（包含 system prompt）
    const context = getContext(newMessages, state.currentMode);

    // 4. 流式发送给模型
    try {
      await sendMessageStream(
        context,
        // onChunk: 接收到新内容时更新消息
        (newContent: string) => {
          setState((prev) => ({
            ...prev,
            messages: prev.messages.map((msg) =>
              msg.id === assistantMessageId
                ? { ...msg, content: msg.content + newContent }
                : msg
            ),
          }));
        },
        // onComplete: 流式输出完成
        () => {
          setState((prev) => ({
            ...prev,
            loading: false,
          }));
        },
        // onError: 错误处理
        (error: Error) => {
          setState((prev) => ({
            ...prev,
            loading: false,
            error: error.message,
          }));
        }
      );
    } catch (error) {
      setState((prev) => ({
        ...prev,
        loading: false,
        error: (error as Error).message,
      }));
    }
  };

  // 清除错误
  const handleClearError = () => {
    setState((prev) => ({
      ...prev,
      error: null,
    }));
  };

  // 清空对话
  const handleClearChat = () => {
    setState((prev) => ({
      ...prev,
      messages: [],
      error: null,
    }));
  };

  return (
    <div className={styles.app}>
      {/* 模式选择器 */}
      <ModeSelector
        modes={state.modes}
        currentMode={state.currentMode}
        onModeChange={handleModeChange}
      />

      {/* 错误提示 */}
      {state.error && (
        <div className={styles.errorBanner}>
          <span className={styles.errorMessage}>{state.error}</span>
          <button
            className={styles.errorClose}
            onClick={handleClearError}
          >
            ✕
          </button>
        </div>
      )}

      {/* 聊天列表 */}
      <ChatList
        messages={state.messages}
        loading={state.loading}
      />

      {/* 输入框 */}
      <ChatInput
        onSend={handleSend}
        isLoading={state.loading}
        onClearChat={handleClearChat}
      />
    </div>
  );
}

export default App;
```

## 2. App.module.css 样式

```css
.app {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background: #f5f5f5;
}

.errorBanner {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  background: #ffebee;
  border-bottom: 1px solid #ffcdd2;
  color: #c62828;
  font-size: 14px;
}

.errorMessage {
  flex: 1;
}

.errorClose {
  padding: 4px 8px;
  background: none;
  border: none;
  color: #c62828;
  cursor: pointer;
  font-size: 16px;
  font-weight: bold;
}

.errorClose:hover {
  background: rgba(198, 40, 40, 0.1);
  border-radius: 4px;
}
```

## 3. 状态管理要点

### 3.1 状态结构设计

```typescript
interface AppState {
  messages: Message[];      // 消息列表
  loading: boolean;         // 是否正在加载
  error: string | null;     // 错误信息
  currentMode: Mode;        // 当前模式
  modes: Mode[];            // 所有可用模式
}
```

### 3.2 函数式更新模式

```typescript
// ✅ 推荐：使用函数式更新
setState((prev) => ({
  ...prev,
  messages: [...prev.messages, newMessage],
}));

// ❌ 避免：直接依赖当前状态
setState({
  ...state,
  messages: [...state.messages, newMessage],
});
```

### 3.3 流式输出的状态更新

```typescript
// 创建空消息占位符
const assistantMessageId = Date.now().toString();
const assistantMessage: Message = {
  id: assistantMessageId,
  role: 'assistant',
  content: '',
};

// 添加占位符到消息列表
setState(prev => ({
  ...prev,
  messages: [...prev.messages, assistantMessage],
}));

// 流式更新消息内容
onChunk: (newContent: string) => {
  setState(prev => ({
    ...prev,
    messages: prev.messages.map(msg =>
      msg.id === assistantMessageId
        ? { ...msg, content: msg.content + newContent }
        : msg
    ),
  }));
}
```

## 4. 进阶状态管理

### 4.1 使用 useReducer 管理复杂状态

```typescript
type AppAction =
  | { type: 'ADD_MESSAGE'; payload: Message }
  | { type: 'UPDATE_MESSAGE'; payload: { id: string; content: string } }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'CHANGE_MODE'; payload: Mode }
  | { type: 'CLEAR_CHAT' };

function appReducer(state: AppState, action: AppAction): AppState {
  switch (action.type) {
    case 'ADD_MESSAGE':
      return {
        ...state,
        messages: [...state.messages, action.payload],
      };
    case 'UPDATE_MESSAGE':
      return {
        ...state,
        messages: state.messages.map(msg =>
          msg.id === action.payload.id
            ? { ...msg, content: action.payload.content }
            : msg
        ),
      };
    case 'SET_LOADING':
      return {
        ...state,
        loading: action.payload,
      };
    case 'SET_ERROR':
      return {
        ...state,
        error: action.payload,
      };
    case 'CHANGE_MODE':
      return {
        ...state,
        currentMode: action.payload,
      };
    case 'CLEAR_CHAT':
      return {
        ...state,
        messages: [],
        error: null,
      };
    default:
      return state;
  }
}

function App() {
  const [state, dispatch] = useReducer(appReducer, initialState);

  const handleSend = async (content: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content,
    };

    dispatch({ type: 'ADD_MESSAGE', payload: userMessage });
    dispatch({ type: 'SET_LOADING', payload: true });

    // ... 流式发送
    onChunk: (newContent) => {
      dispatch({
        type: 'UPDATE_MESSAGE',
        payload: { id: assistantMessageId, content: newContent },
      });
    }
  };
}
```

### 4.2 持久化状态到 localStorage

```typescript
import { useEffect } from 'react';

function App() {
  const [state, setState] = useState<AppState>(() => {
    // 从 localStorage 初始化状态
    const saved = localStorage.getItem('chat-app-state');
    if (saved) {
      try {
        return JSON.parse(saved);
      } catch (e) {
        console.error('Failed to load state:', e);
      }
    }
    return initialState;
  });

  // 保存状态到 localStorage
  useEffect(() => {
    localStorage.setItem('chat-app-state', JSON.stringify(state));
  }, [state]);

  // ...
}
```

### 4.3 状态持久化优化（只持久化消息）

```typescript
useEffect(() => {
  // 只持久化消息，不持久化 loading 和 error
  localStorage.setItem('chat-messages', JSON.stringify(state.messages));
}, [state.messages]);

// 初始化时加载消息
const [state, setState] = useState<AppState>(() => {
  const savedMessages = localStorage.getItem('chat-messages');
  const messages = savedMessages ? JSON.parse(savedMessages) : [];
  return {
    messages,
    loading: false,
    error: null,
    currentMode: MODES[0],
    modes: MODES,
  };
});
```

## 5. 性能优化

### 5.1 使用 useMemo 优化计算

```typescript
import { useMemo } from 'react';

function App() {
  const [state, setState] = useState<AppState>(initialState);

  // 缓存上下文计算
  const context = useMemo(() => {
    return getContext(state.messages, state.currentMode);
  }, [state.messages, state.currentMode]);

  // 缓存最后一条消息
  const lastMessage = useMemo(() => {
    return state.messages[state.messages.length - 1];
  }, [state.messages]);
}
```

### 5.2 使用 useCallback 优化回调

```typescript
import { useCallback } from 'react';

function App() {
  const [state, setState] = useState<AppState>(initialState);

  const handleModeChange = useCallback((mode: Mode) => {
    setState((prev) => ({
      ...prev,
      currentMode: mode,
    }));
  }, []);

  const handleSend = useCallback(async (content: string) => {
    // 发送逻辑
  }, [state.currentMode]); // 依赖 currentMode

  return (
    <ModeSelector
      modes={state.modes}
      currentMode={state.currentMode}
      onModeChange={handleModeChange}
    />
  );
}
```

## 6. 测试状态管理

```typescript
// 测试用例
describe('App State Management', () => {
  it('should add user message', () => {
    const { result } = renderHook(() => useState<AppState>(initialState));
    const [, setState] = result.current;

    act(() => {
      setState(prev => ({
        ...prev,
        messages: [...prev.messages, userMessage],
      }));
    });

    expect(result.current[0].messages).toHaveLength(1);
  });

  it('should update message content', () => {
    const { result } = renderHook(() => useState<AppState>(initialState));
    const [, setState] = result.current;

    act(() => {
      setState(prev => ({
        ...prev,
        messages: prev.messages.map(msg =>
          msg.id === 'msg-1'
            ? { ...msg, content: 'Updated content' }
            : msg
        ),
      }));
    });

    expect(result.current[0].messages[0].content).toBe('Updated content');
  });
});
```

## 你的任务

1. 更新 `src/App.tsx`，实现完整的模式系统和流式输出
2. 更新 `src/App.module.css`，添加错误提示样式
3. 集成 ModeSelector、ChatList、ChatInput 组件
4. 实现流式输出的状态更新逻辑

完成后告诉我："我写好了，你检查一下 @src/App.tsx"