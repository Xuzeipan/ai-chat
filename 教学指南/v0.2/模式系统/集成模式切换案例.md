# 集成模式切换案例

## 1. 在 App 中集成 ModeSelector

```typescript
import React, { useState } from 'react';
import { ModeSelector } from './components/ModeSelector';
import { ChatList } from './components/ChatList';
import { ChatInput } from './components/ChatInput';
import { Message, Mode } from './types';
import { sendMessage } from './services/chat';
import MODES from './config/modes';
import styles from './App.module.css';

interface AppState {
  messages: Message[];
  loading: boolean;
  error: string | null;
  currentMode: Mode;
  modes: Mode[];
}

function App() {
  const [state, setState] = useState<AppState>({
    messages: [],
    loading: false,
    error: null,
    currentMode: MODES[0],  // 默认模式
    modes: MODES,
  });

  // 模式切换处理
  const handleModeChange = (mode: Mode) => {
    setState((prev) => ({
      ...prev,
      currentMode: mode,
    }));
  };

  // 发送消息处理
  const handleSend = async (content: string) => {
    if (!content.trim() || state.loading) return;

    // 1. 添加用户消息
    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content: content.trim(),
    };

    setState((prev) => ({
      ...prev,
      messages: [...prev.messages, userMessage],
      loading: true,
      error: null,
    }));

    // 2. 发送给 API
    try {
      const reply = await sendMessage(content);
      // 3. 添加 AI 回复
      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: reply,
      };

      setState((prev) => ({
        ...prev,
        messages: [...prev.messages, assistantMessage],
        loading: false,
      }));
    } catch (error) {
      setState((prev) => ({
        ...prev,
        loading: false,
        error: (error as Error).message,
      }));
    }
  };

  return (
    <div className={styles.app}>
      {/* 模式选择器 */}
      <ModeSelector
        modes={state.modes}
        currentMode={state.currentMode}
        onModeChange={handleModeChange}
      />

      {/* 错误提示 */}
      {state.error && (
        <div className={styles.errorBanner}>
          <span className={styles.errorMessage}>{state.error}</span>
          <button
            className={styles.errorClose}
            onClick={() => setState(prev => ({ ...prev, error: null }))}
          >
            ✕
          </button>
        </div>
      )}

      {/* 聊天列表 */}
      <ChatList
        messages={state.messages}
        loading={state.loading}
      />

      {/* 输入框 */}
      <ChatInput
        onSend={handleSend}
        isLoading={state.loading}
      />
    </div>
  );
}

export default App;
```

## 2. 测试模式切换

### 测试步骤
1. 启动应用
2. 点击不同的模式按钮
3. 观察当前模式是否正确切换
4. 检查模式按钮的激活状态

### 验证点
- ✅ 点击模式按钮后，currentMode 正确更新
- ✅ 当前模式的按钮显示激活状态（蓝色背景）
- ✅ 其他模式的按钮显示未激活状态（白色背景）
- ✅ 模式切换不影响已有的消息列表

## 3. 当前模式显示

```typescript
// 在 App 中显示当前模式
<div className={styles.app}>
  <div className={styles.header}>
    <ModeSelector
      modes={state.modes}
      currentMode={state.currentMode}
      onModeChange={handleModeChange}
    />
    <div className={styles.currentModeInfo}>
      当前模式: {state.currentMode.name}
    </div>
  </div>
  {/* ... */}
</div>
```

```css
/* App.module.css */
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  background: #f5f5f5;
  border-bottom: 1px solid #e0e0e0;
}

.currentModeInfo {
  font-size: 14px;
  color: #666;
}
```

## 4. 模式切换提示

```typescript
// 添加模式切换提示
const handleModeChange = (mode: Mode) => {
  if (mode.id === state.currentMode.id) return;  // 已经是当前模式，不处理

  setState((prev) => ({
    ...prev,
    currentMode: mode,
  }));

  // 可选：添加过渡动画或提示
  console.log(`切换到模式: ${mode.name}`);
};
```

## 5. 模式持久化（可选）

```typescript
import { useEffect } from 'react';

function App() {
  const [state, setState] = useState<AppState>(() => {
    // 从 localStorage 读取当前模式
    const savedMode = localStorage.getItem('current-mode');
    const currentMode = savedMode
      ? MODES.find(m => m.id === savedMode) || MODES[0]
      : MODES[0];

    return {
      messages: [],
      loading: false,
      error: null,
      currentMode,
      modes: MODES,
    };
  });

  // 保存当前模式到 localStorage
  useEffect(() => {
    localStorage.setItem('current-mode', state.currentMode.id);
  }, [state.currentMode]);

  // ...
}
```

## 6. 优化建议：modes 不需要放在 state 中

因为 `modes` 是静态配置，不会改变，所以不需要放在 state 中。可以优化为：

```typescript
// 定义 AppState 时排除 modes
interface AppState {
  messages: Message[];
  loading: boolean;
  error: string | null;
  currentMode: Mode;
  // modes: Mode[];  // ← 不需要放在 state 中
}

function App() {
  const [state, setState] = useState<Omit<AppState, 'modes'>>({
    messages: [],
    loading: false,
    error: null,
    currentMode: MODES[0],
  });

  // 使用时直接用导入的 MODES 常量
  return (
    <div className={styles.app}>
      <ModeSelector
        modes={MODES}  // ← 直接用导入的常量
        currentMode={state.currentMode}
        onModeChange={handleModeChange}
      />
      {/* ... */}
    </div>
  );
}
```

**优点**：
- 减少 state 的复杂度
- modes 是静态配置，不需要响应式更新
- 代码更清晰

## 你的任务

1. 更新 `src/App.tsx`，集成 ModeSelector 组件
2. 实现 handleModeChange 函数
3. 测试模式切换功能
4. 验证模式切换不影响其他功能
5. （可选）应用优化建议，将 modes 从 state 中移除

完成后告诉我："我写好了，你检查一下 @src/App.tsx"