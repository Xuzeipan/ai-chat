# v0.2 模式系统规划

## 核心概念

### 什么是模式（Mode）？

**模式 = 前端控制 AI 模型行为的方式**

通过前端设置不同的"行为规则"，让同一个 AI 模型表现出完全不同的"人格"。

### 三件"AI 前端"的事

#### 1️⃣ 系统角色（System Prompt）
- **什么是 System Prompt**：告诉模型"你是谁"的指令
- **特点**：
  - 用户看不到
  - 决定模型行为
  - 可以随时切换
- **例子**：
  - 普通聊天：你是一个有帮助的 AI 助手
  - 前端导师：你是一位有 10 年经验的前端工程师，擅长 React 和 TypeScript

#### 2️⃣ 上下文控制
- **问题**：不是把所有历史都发给模型
- **方案**：发送最近的 N 条对话
- **发送给模型的结构**：
  ```typescript
  [
    { role: "system", content: "你是前端导师" },  ← 系统提示
    { role: "user", content: "怎么学 React" },     ← 最近 N 条
    { role: "assistant", content: "..." },
    { role: "user", content: "推荐个教程" }
  ]
  ```
- **为什么这样做**：
  - 节省 token（降低成本）
  - 保持对话连贯性
  - 避免模型被过多历史信息干扰

#### 3️⃣ 前端主导模型行为
- **核心思想**：模型不是自由发挥，是被前端"圈"在行为空间里
- **前端控制**：
  - 选择哪个 system prompt
  - 发送多少历史消息
  - 如何处理响应

---

## 功能需求

### 1. 模式管理
- 定义多个模式（普通聊天、前端导师、代码审查等）
- 模式切换功能
- 模式配置（系统提示、上下文长度等）

### 2. 上下文管理
- 滑动窗口（只发送最近 N 条消息）
- System Prompt 注入
- 上下文长度优化

### 3. 用户界面
- 模式选择器
- 当前模式显示
- 模式切换动画

---

## 实现步骤

### 步骤 1：类型定义
```typescript
// 模式类型
interface Mode {
  id: string;
  name: string;
  description: string;
  systemPrompt: string;
  contextLength: number;  // 保留的对话条数
  icon?: string;
}

// 应用状态扩展
interface AppState {
  messages: Message[];
  loading: boolean;
  error: string | null;
  currentMode: Mode;  // 当前模式
  modes: Mode[];      // 所有可用模式
}
```

### 步骤 2：模式配置
```typescript
// 预定义模式
const MODES: Mode[] = [
  {
    id: 'normal',
    name: '普通聊天',
    description: '通用 AI 助手',
    systemPrompt: '你是一个有帮助的 AI 助手，用简洁、友好的方式回答问题。',
    contextLength: 10,
  },
  {
    id: 'frontend-mentor',
    name: '前端导师',
    description: '10 年经验的前端工程师',
    systemPrompt: '你是一位有 10 年经验的前端工程师，擅长 React、TypeScript 和现代前端开发。你的回答要专业、实用，并给出代码示例。鼓励用户提问，引导他们深入思考。',
    contextLength: 15,
  },
  {
    id: 'code-reviewer',
    name: '代码审查',
    description: '严格的代码审查专家',
    systemPrompt: '你是一位严格的代码审查专家。专注于代码质量、性能优化和最佳实践。指出问题并给出改进建议。',
    contextLength: 20,
  },
];
```

### 步骤 3：上下文管理
```typescript
// 获取发送给模型的上下文
function getContext(messages: Message[], mode: Mode): Message[] {
  // 1. 添加 system prompt
  const systemMessage: Message = {
    id: 'system',
    role: 'system',
    content: mode.systemPrompt,
  };

  // 2. 获取最近 N 条对话
  const recentMessages = messages.slice(-mode.contextLength);

  // 3. 组合返回
  return [systemMessage, ...recentMessages];
}
```

### 步骤 4：API 服务改造
```typescript
// 修改 sendMessage 接受上下文
export async function sendMessage(
  content: string,
  context: Message[]
): Promise<string> {
  const request: OllamaChatRequest = {
    model: "qwen2.5-coder:7b",
    messages: context.map(msg => ({
      role: msg.role,
      content: msg.content,
    })),
    stream: false,
  };

  // ... 发送请求
}
```

### 步骤 5：UI 组件
```typescript
// ModeSelector 组件
interface ModeSelectorProps {
  modes: Mode[];
  currentMode: Mode;
  onModeChange: (mode: Mode) => void;
}

export function ModeSelector({
  modes,
  currentMode,
  onModeChange,
}: ModeSelectorProps) {
  return (
    <div className={styles.modeSelector}>
      {modes.map((mode) => (
        <button
          key={mode.id}
          className={`${styles.modeButton} ${
            mode.id === currentMode.id ? styles.active : ''
          }`}
          onClick={() => onModeChange(mode)}
        >
          <span className={styles.modeIcon}>{mode.icon || '💬'}</span>
          <span className={styles.modeName}>{mode.name}</span>
        </button>
      ))}
    </div>
  );
}
```

### 步骤 6：状态管理更新
```typescript
function App() {
  const [state, setState] = useState<AppState>({
    messages: [],
    loading: false,
    error: null,
    currentMode: MODES[0],  // 默认模式
    modes: MODES,
  });

  const handleModeChange = (mode: Mode) => {
    setState((prev) => ({
      ...prev,
      currentMode: mode,
    }));
  };

  const handleSend = async (content: string) => {
    // 1. 添加用户消息
    const userMessage = {
      id: Date.now().toString(),
      role: "user" as const,
      content,
    };

    setState((prev) => ({
      ...prev,
      messages: [...prev.messages, userMessage],
      loading: true,
    }));

    // 2. 获取上下文（包含 system prompt）
    const context = getContext(
      [...state.messages, userMessage],
      state.currentMode
    );

    // 3. 发送给模型
    try {
      const reply = await sendMessage(content, context);

      // 4. 添加 AI 回复
      const assistantMessage = {
        id: (Date.now() + 1).toString(),
        role: "assistant" as const,
        content: reply,
      };

      setState((prev) => ({
        ...prev,
        messages: [...prev.messages, assistantMessage],
        loading: false,
      }));
    } catch (error) {
      // 错误处理
    }
  };
}
```

---

## 技术要点

### 1. System Prompt 的作用
- **定义角色**：告诉模型"你是谁"
- **设定行为**：规定模型如何回答
- **控制范围**：限制模型的回答边界

### 2. 上下文窗口
- **为什么需要**：模型有 token 限制（通常是 4096 或 8192）
- **滑动窗口**：只保留最近 N 条对话
- **优化策略**：
  - 重要对话可以标记，保留更久
  - 可以压缩旧对话（摘要）
  - 根据模式动态调整上下文长度

### 3. 前端主导
- **模型是工具**：前端是"导演"，模型是"演员"
- **行为空间**：前端通过 system prompt 定义"剧本"
- **动态调整**：根据用户反馈调整行为

---

## 进阶功能

### 1. 自定义模式
- 用户可以创建自己的模式
- 编辑 system prompt
- 调整上下文长度

### 2. 模式记忆
- 记住用户在某个模式下的对话
- 切换模式时保留各自的历史

### 3. 模式推荐
- 根据用户问题自动推荐合适的模式
- 学习用户的模式偏好

### 4. 多模式对话
- 同一个对话中切换模式
- 不同模式处理不同类型的问题

---

## 测试验证

### 测试场景
1. **普通聊天模式**
   - 问：今天天气怎么样？
   - 期望：友好的回答

2. **前端导师模式**
   - 问：怎么学 React？
   - 期望：专业、有代码示例、引导深入

3. **代码审查模式**
   - 问：帮我看看这段代码
   - 期望：严格审查、指出问题、给出建议

### 验证点
- ✅ 模式切换后，回答风格明显不同
- ✅ 上下文正确传递
- ✅ System Prompt 不泄露给用户
- ✅ 上下文长度控制有效

---

## 学习收获

通过实现模式系统，你将学到：

1. **系统提示工程**：如何设计有效的 system prompt
2. **上下文管理**：如何优化对话历史
3. **前端主导 AI**：如何通过前端控制模型行为
4. **状态管理进阶**：复杂状态的拆分和管理
5. **用户体验设计**：如何让模式切换自然流畅

---

## 下一步

1. 实现基础模式系统（2 个模式）
2. 添加上下文管理
3. 优化 UI 交互
4. 测试不同模式的行为差异
5. 扩展更多模式