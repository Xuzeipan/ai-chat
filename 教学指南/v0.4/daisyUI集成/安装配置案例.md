# daisyUI 安装配置案例

## 基础实现

### 1. 安装依赖

```bash
pnpm --filter @ai-chat/client add -D tailwindcss @tailwindcss/vite daisyui
```

### 2. 配置 Vite

修改 `apps/client/vite.config.ts`：

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'
import { resolve } from 'path'

export default defineConfig({
  plugins: [
    react(),
    tailwindcss(),  // 添加 Tailwind CSS 插件
  ],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  },
  server: {
    port: 5173
  }
})
```

### 3. 配置 Tailwind CSS

创建 `apps/client/src/index.css`（替换原有内容）：

```css
@import "tailwindcss";

@plugin "daisyui";

/* 配置 daisyUI 主题 */
@plugin "daisyui" {
  themes: cupcake, dark;
  darkTheme: dark;
  base: true;
  styled: true;
  utils: true;
}

/* 全局基础样式 */
body {
  margin: 0;
  padding: 0;
  min-height: 100vh;
}

/* 自定义滚动条样式 */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: oklch(0.6 0.01 200 / 0.3);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: oklch(0.5 0.01 200 / 0.4);
}
```

### 4. 主题切换工具

创建 `apps/client/src/utils/theme.ts`：

```typescript
export type Theme = 'cupcake' | 'dark';

const THEME_KEY = 'ai-chat-theme';

export const getStoredTheme = (): Theme => {
  const stored = localStorage.getItem(THEME_KEY);
  if (stored === 'cupcake' || stored === 'dark') {
    return stored;
  }
  return 'cupcake'; // 默认主题
};

export const setStoredTheme = (theme: Theme): void => {
  localStorage.setItem(THEME_KEY, theme);
};

export const applyTheme = (theme: Theme): void => {
  document.documentElement.setAttribute('data-theme', theme);
};

export const initTheme = (): void => {
  const theme = getStoredTheme();
  applyTheme(theme);
};
```

### 5. 主题切换组件

创建 `apps/client/src/components/ThemeToggle/ThemeToggle.tsx`：

```typescript
import { useState, useEffect } from 'react';
import { getStoredTheme, setStoredTheme, applyTheme, type Theme } from '@/utils/theme';

export default function ThemeToggle() {
  // 使用初始化函数，避免在 Effect 中调用 setState 导致级联渲染
  const [theme, setTheme] = useState<Theme>(() => getStoredTheme());

  // 主题变化时应用到 DOM 和 localStorage
  useEffect(() => {
    applyTheme(theme);
    setStoredTheme(theme);
  }, [theme]);

  const toggleTheme = () => {
    setTheme(prev => prev === 'cupcake' ? 'dark' : 'cupcake');
  };

  return (
    <button
      onClick={toggleTheme}
      className="btn btn-ghost btn-circle"
      aria-label="切换主题"
    >
      {theme === 'cupcake' ? (
        // 太阳图标（当前是亮色主题）
        <svg
          xmlns="http://www.w3.org/2000/svg"
          className="h-5 w-5"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
          />
        </svg>
      ) : (
        // 月亮图标（当前是暗色主题）
        <svg
          xmlns="http://www.w3.org/2000/svg"
          className="h-5 w-5"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
          />
        </svg>
      )}
    </button>
  );
}
```

### 6. 修改入口文件

修改 `apps/client/src/main.tsx`（不需要再初始化主题，由 ThemeToggle 组件管理）：

```typescript
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import './index.css';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

**说明**：主题初始化现在由 ThemeToggle 组件的 `useState(() => getStoredTheme())` 处理，避免了在 useEffect 中调用 setState 导致的级联渲染警告。

## 使用示例

### 在 App.tsx 中添加主题切换按钮

```typescript
import ThemeToggle from '@/components/ThemeToggle/ThemeToggle';

// 在 Header 或适当位置添加
<header className="navbar bg-base-100 shadow-sm">
  <div className="flex-1">
    <h1 className="text-xl font-bold">AI Chat</h1>
  </div>
  <div className="flex-none gap-2">
    <ThemeToggle />
  </div>
</header>
```

### 使用 daisyUI 组件类名

```tsx
// 按钮
<button className="btn btn-primary">发送</button>

// 卡片
<div className="card bg-base-200 shadow-sm">
  <div className="card-body">
    <h2 className="card-title">标题</h2>
    <p>内容</p>
  </div>
</div>

// 输入框
<input
  type="text"
  className="input input-bordered w-full"
  placeholder="输入消息..."
/>

// 气泡/聊天气泡
<div className="chat chat-start">
  <div className="chat-bubble">用户消息</div>
</div>
<div className="chat chat-end">
  <div className="chat-bubble chat-bubble-primary">AI 回复</div>
</div>
```

## 原理解释

### Tailwind CSS 4.0 + Vite

Tailwind CSS 4.0 使用新的导入方式 `@import "tailwindcss"`，通过 Vite 插件 `@tailwindcss/vite` 处理，不需要传统的 `tailwind.config.js` 文件。

### daisyUI 主题系统

daisyUI 使用 CSS 变量实现主题切换。通过设置 `data-theme` 属性，所有组件会自动应用对应主题的配色。

```html
<html data-theme="cupcake">
  <!-- 所有 daisyUI 组件显示 cupcake 主题配色 -->
</html>

<html data-theme="dark">
  <!-- 所有 daisyUI 组件显示 dark 主题配色 -->
</html>
```

### 颜色约定

daisyUI 提供语义化颜色类名：
- `bg-base-100` - 主背景色
- `bg-base-200` - 次要背景色
- `bg-base-300` - 第三背景色
- `text-base-content` - 主要文字色
- `text-primary-content` - 主题色上的文字
- `btn-primary` - 主题色按钮
- `btn-secondary` - 次要色按钮

这些颜色会根据当前主题自动变化。

### cupcake vs dark 主题特点

**cupcake**：
- 主色：粉色系
- 背景：浅色
- 适合：白天使用，清新活泼

**dark**：
- 主色：紫/蓝色系
- 背景：深色
- 适合：夜间使用，护眼

## 进阶功能：跟随系统主题（⏳ 待规划）

> **注意**：此功能暂时搁置，后续配合"多主题选择"功能一起重构。
>
> 当前逻辑问题：用 localStorage 是否存在来判断是否手动设置主题不准确（跟随系统时也会写入）。

### 实现思路（未来规划）

1. **首次访问**（无存储主题）：跟随系统主题
2. **手动切换**：使用用户选择的主题，并存入 localStorage（标记为手动选择）
3. **监听系统**：仅当用户未手动选择时，系统主题变化才自动切换

### 修改步骤

#### 第1步：修改 theme.ts

**添加 `hasStoredTheme` 函数**（用于判断用户是否手动设置过主题）：

```typescript
export type Theme = "cupcake" | "dark";

const THEME_KEY = "ai-chat-theme";

export const getStoredTheme = (): Theme | null => {
  const stored = localStorage.getItem(THEME_KEY);
  if (stored === "cupcake" || stored === "dark") {
    return stored;
  }
  return null;  // 没有存储返回 null
};

export const setStoredTheme = (theme: Theme): void => {
  localStorage.setItem(THEME_KEY, theme);
};

// 新增：判断是否手动设置过主题
export const hasStoredTheme = (): boolean => {
  return localStorage.getItem(THEME_KEY) !== null;
};

// 新增：获取系统主题
export const getSystemTheme = (): Theme => {
  if (typeof window === "undefined") return "cupcake";
  return window.matchMedia("(prefers-color-scheme: dark)").matches
    ? "dark"
    : "cupcake";
};

export const applyTheme = (theme: Theme): void => {
  document.documentElement.setAttribute("data-theme", theme);
};

// 删除原来的 initTheme 函数，逻辑移到组件里
```

#### 第2步：修改 ThemeToggle.tsx

**完整代码**：

```typescript
import { useEffect, useState } from "react";
import {
  applyTheme,
  getStoredTheme,
  setStoredTheme,
  hasStoredTheme,
  getSystemTheme,
  type Theme,
} from "@/utils/theme";

export default function ThemeToggle() {
  // 初始化：优先使用存储的主题，否则跟随系统
  const [theme, setTheme] = useState<Theme>(() => {
    const stored = getStoredTheme();
    return stored ?? getSystemTheme();
  });

  // 主题变化时应用并存储
  useEffect(() => {
    applyTheme(theme);
    setStoredTheme(theme);
  }, [theme]);

  // 监听系统主题变化（仅在用户未手动设置时生效）
  useEffect(() => {
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");

    const handleChange = (e: MediaQueryListEvent) => {
      // 如果用户没有手动设置过主题，跟随系统变化
      if (!hasStoredTheme()) {
        setTheme(e.matches ? "dark" : "cupcake");
      }
    };

    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, []);

  const toggleTheme = () => {
    setTheme((prev) => (prev === "cupcake" ? "dark" : "cupcake"));
  };

  return (
    <button
      onClick={toggleTheme}
      className="btn btn-ghost btn-circle"
      aria-label="切换主题"
    >
      {theme === "cupcake" ? (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          className="h-5 w-5"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
          />
        </svg>
      ) : (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          className="h-5 w-5"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
          />
        </svg>
      )}
    </button>
  );
}
```

### 关键修改点说明

| 修改 | 原代码 | 新代码 | 作用 |
|------|--------|--------|------|
| `getStoredTheme` 返回值 | `Theme` | `Theme \| null` | 区分"无存储"和"默认主题" |
| 初始化逻辑 | `getStoredTheme()` | `stored ?? getSystemTheme()` | 无存储时跟随系统 |
| 新增 Effect | 无 | 监听 `matchMedia` | 系统主题变化时自动切换 |
| 条件判断 | 无 | `!hasStoredTheme()` | 仅用户未手动设置时才跟随系统 |

### 常见问题：matchMedia 始终返回 false

如果 `window.matchMedia('(prefers-color-scheme: dark)').matches` 一直返回 `false`：

#### 1. 检查浏览器 DevTools 设置

最常见的原因：**浏览器开发者工具强制覆盖了外观设置**

**Chrome**:
1. 打开 DevTools (`Cmd+Option+I`)
2. 点击右上角三个点 → Settings（或按 `?`）
3. Preferences → Appearance
4. 取消勾选 **"Emulate CSS media feature prefers-color-scheme"** 或选择 **"No emulation"**

**Safari**:
1. 开发菜单 → 模拟 → 取消 "暗色模式" 或 "外观: 暗色"

**快捷检测**: 控制台如果出现太阳/月亮图标，说明正在模拟主题。

#### 2. 降级方案（时间推断）

如果无法检测系统主题，可按时间推断：

```typescript
export const getSystemTheme = (): Theme => {
  if (typeof window === "undefined") return "cupcake";

  // 尝试检测系统主题
  const isDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
  if (isDark) return "dark";

  // 降级：晚上8点到早上6点用暗色
  const hour = new Date().getHours();
  return (hour >= 20 || hour < 6) ? "dark" : "cupcake";
};
```

## 你的任务

1. **安装依赖**：在 client 目录下安装 Tailwind CSS、@tailwindcss/vite 和 daisyui

2. **配置 Vite**：修改 vite.config.ts，添加 tailwindcss 插件

3. **更新 CSS**：用上面的内容替换 index.css（保留自定义滚动条样式）

4. **创建主题工具**：创建 utils/theme.ts，实现主题的存储和应用

5. **创建主题切换组件**：创建 components/ThemeToggle/ThemeToggle.tsx

6. **修改入口文件**：简化 main.tsx（主题初始化由 ThemeToggle 组件处理，无需手动调用）

7. **验证配置**：
   - 运行 `pnpm client dev`
   - 在 App.tsx 中添加 `<ThemeToggle />`
   - 点击按钮，验证主题切换正常
   - 刷新页面，验证主题记忆功能正常

完成后告诉我："我写好了，你检查一下 @apps/client/src/utils/theme.ts 和其他相关文件"
